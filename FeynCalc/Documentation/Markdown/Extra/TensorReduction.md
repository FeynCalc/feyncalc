## Tensor reduction

### See also

[Overview](FeynCalc.md).

### Brief description

Loop tensor integrals that depend on loop momenta with open indices can be converted to scalar integrals by means of tensor reduction. The same also applies to cases where the loop momenta are contracted with Dirac matrices, Levi-Civita tensors, polarization vectors or any other $4$-vectors that are not contained in the propagators of the respective loop integrals.

This technique is usually called [Passarino-Veltman reduction](https://doi.org/10.1016/0550-3213(79)90234-7}) or simply _tensor reduction_. The main idea is to start from the most generic ansatz for the tensor structures (e.g. $g^{\mu \nu}$, $p_1^\mu p_1^\nu$, $p_2^\mu p_2^\nu$, $p_2^\mu p_1^\nu$  and $p_1^\mu p_2^\nu$ for a 3-point rank 2 integral) that can appear in the final result and use it to write down a tensor equation with unknown scalar coefficients $S_i$ multiplying those structures. The tensor structures may only contain metric tensors and the external momenta the given loop integral depends on.

Then, contracting the resulting tensor equation with the present tensor structures one can obtain a linear system of equations and solve it for $S_i$. The size of the linear system can be considerably simplified by making use of the symmetries between different coefficients, e.g. by employing [Pak's algorithm](https://arxiv.org/pdf/1111.0868).

### Implementation

FeynCalc features several routines that implement this procedure. At 1 loop it is convenient to use [TID](../TID.md) that can reduce tensor integrals with quadratic propagators to scalar integrals with unit numerators. The result can be also presented in terms of the so-called Passarino-Veltman coefficient (e.g $B_{11}$, $C_{00}$, $D_{1}$ etc.) or scalar functions ($A_0$, $B_0$, $C_0$, $D_0$).

Loop integrals with more generic propagators as well as integrals with more loops can be treated using [FCMultiLoopTID](../FCMultiLoopTID.md). For such integrals the reduction to unit numerators is not always possible. Therefore, the function merely tries to get rid of loop momenta with open indices by converting the original integral into a linear combination of scalar integrals multiplying tensor structures made of metric tensors and external momenta. The scalar integrals still may have numerators with loop momenta contracted to other loop momenta or external momenta.

To reduce such expressions to a set of simpler integrals it is necessary to use IBP-reduction tools that can be accessed e.g. via the FeynHelpers add-on.

Calculations that make use of the multiloop functionality introduced in FeynCalc 10 require a somewhat different approach. To deal with amplitudes written in terms of [GLIs](../GLI.md) as they are usually generated by [FCLoopFindTopologies](../FCLoopFindTopologies.md), one should use the special function [FCLoopTensorReduce](../FCLoopTensorReduce.md).

Last but not least, sometimes one wants to calculate a tensor reduction formula without referring to a particular integral, but rather just specifying the tensor structure and the external momenta. This is useful e.g. when using such tools as [FORM](https://github.com/vermaseren/form). To this aim one can use the auxiliary routine [Tdec](../Tdec.md).

### Reduction for zero Gram determinants

The naive Passarino-Veltman reduction breaks down when the Gram determinant of the given set of external momenta vanishes. A zero Gramian means that the external momenta are linearly dependent, i.e. there is a redundancy in the reduction. In this case the linear system constructed out of these momenta is not solvable and it is not possible to determine the coefficients $S_i$.

One way to circumvent this issue consists of constructing a new set of external momenta, where all vectors are linearly independent from each other. Reducing the loop integral with respect to these new vectors produces a solvable linear system which effectively resolves the problem. Here one should distinguish between two possible cases.

#### New basis using only available momenta

If the new set of linearly independent momenta is just a subset of the old external momenta, then the reduction can be done straightforwardly. The same goes for the subsequent IBP reduction. In particular, it is not necessary to tell the IBP-reduction tool which external momenta are linearly dependent.


#### New basis containing auxiliary momentum

Unfortunately, for some kinematic configurations the available external momenta are not sufficient to produce a valid tensor basis. This usually happens when almost all external momenta are light-like (i.e. their squares vanish). The simplest example for this case is the 2-point function with $p^2=0$, e.g. 

\begin{equation}
\int_k k^{\mu} f(k,p,m_i) = p^\mu A(p,m_i).
\end{equation}

Contracting this equation with $p^{\mu}$ we get zero on the right hand side, which does not allow us to extract the value of $A(p,m_i)$. Solving it for $p^2 \neq 0$ also would not help, as the limit $p \to 0$ cannot be taken naively.

The workaround here (and for all similar cases) is to extend the tensor basis by adding an auxiliary momentum (say $n$). For simplicity, it is convenient to choose this auxiliary momentum to be light-like (i.e. $n^2=0$), but this condition is not strictly necessary. On the other hand, it is very important to stress that the scalar products of $n$ with other external momenta ($n \cdot p_i$) must be nonvanishing. The new equation

\begin{equation}
\int_k k^{\mu} f(k,p,m_i) = p^\mu \tilde{A}(p,m_i) + n^\mu \tilde{B}(p,m_i)
\end{equation}

leads to

\begin{equation}
\tilde{A}(p,m_i) = \frac{1}{n \cdot p} \int_k (n \cdot k) \, f(k,p,m_i), \\
\tilde{B}(p,m_i) = \frac{1}{n \cdot p} \int_k (p \cdot k) \, f(k,p,m_i),
\end{equation}

which formally solves the task of removing loop momenta with open indices in the numerator.

Nevertheless, the results for the so-obtained reduction formulas are not immediately usable in the existing calculation.

First of all, the scalar products of $n$ with the loop momenta in the numerator cannot be removed using partial fraction decomposition even at 1-loop order. This is because the propagators do not depend on $n$, so there is nothing we can cancel those scalar products against.
Hence, to get rid of $n \cdot k_i$ we need to use IBP reduction. What is more, to set up the reduction we need to augment the loop integral topologies with propagators containing $n$. Otherwise our propagator basis will not be complete. In practice it is sufficient to use propagators of the type $1/(k_i \cdot n + i \eta)$ for each loop momentum $k_i$. The reduction also becomes more involved due to the presence of the additional kinematic invariants $n \cdot p_i$.

Second, even upon performing the IBP reduction the final result may still seem to depend on $n$. We know that this cannot be the case, as $n$ is an arbitrary auxiliary vector not present in the original integral. Usually, upon exploiting the existing symmetries between master integrals as well as other external vectors and scalar products one can show that the $n$-dependence cancels as it should. However, for complicated integrals with many kinematic invariants enforcing this cancellation can be tricky.

#### FeynCalc routines


In FeynCalc, the tensor reduction routines ([TID](../TID.md), [FCMultiLoopTID](../FCMultiLoopTID.md), [FCLoopTensorReduce](../FCLoopTensorReduce.md)) will automatically alert the user if the external momenta present in the given loop integrals lead to a zero Gram determinant. The warning message will also contain the exact sets of the problematic momenta.

Each of these sets should be passed to the special function [FCLoopFindTensorBasis](../FCLoopFindTensorBasis.md) as its first argument. The second argument is meant for kinematic constraints, in the case that they have not been already defined via `SPD[...] = ...;`. Finally, the third argument denotes an auxiliary vector that might become necessary in some particular cases (see below).

The output [FCLoopFindTensorBasis](../FCLoopFindTensorBasis.md) will contain a set of linearly independent external momenta and the linear dependencies between the original momenta. The set of linearly independent momenta should be passed to the tensor reduction routines via the option `TensorReductionBasisChange` as follows

```mathematica
TensorReductionBasisChange -> {oldBasis1->newBasis1,oldBasis2->newBasis2, ...}
```

If some of the new bases contain an auxiliary vector, it should be specified via the option `AuxiliaryMomenta`, e.g.

```mathematica
AuxiliaryMomenta -> {n}
```

Finally, when using [TID](../TID.md), to ensure the reduction to unit numerators (only for bases without the auxiliary vector) it can be necessary to specify the relations between scalar products involving loop momenta. Such relations follow from the output of [FCLoopFindTensorBasis](../FCLoopFindTensorBasis.md) and can be passed via the option `FinalSubstitutions`. For example, for two linearly dependent external momenta $p_1$, $p_2$

```mathematica
FCLoopFindTensorBasis[{p1, p2}, {SPD[p1] -> s, SPD[p2] -> s, SPD[p1, p2] -> s}, n]
```

the corresponding substitution reads

```mathematica
FinalSubstitutions -> {SPD[k, p2] -> SPD[k, p1]}
```

Tensor reduction results containing the auxiliary vector $n$ need to be processed further using IBPs. For few simple integrals obtained from [TID](../TID.md) and [FCMultiLoopTID](../FCMultiLoopTID.md) it might be easier to do this via the FeynHelpers interface to the Mathematica version of FIRE.

Large results as well as results originating from [FCLoopTensorReduce](../FCLoopTensorReduce.md) will require a more explicit treatment. To that aim we need to augment the topologies of the affected integrals to contain propagators that depend on $n$. This can be done using [FCLoopAugmentTopology](../FCLoopAugmentTopology.md) where we specify the topology in the first argument and the list of propagators in the second one. Usually, it is sufficient to use an eikonal propagator per each loop momentum, e.g. something like

```mathematica
{newtopo, gliRule} = FCLoopAugmentTopology[oldtopo, {SFAD[{{0, k1.n}}], SFAD[{{0, k2.n}}], ...}]
```

Then we can apply the GLI conversion rule `gliRule` to the output of `FCLoopTensorReduce`

```mathematica
ampRed /. gliRule
```

and use `newtopo` when setting up the IBP reduction.

#### Examples

In the following we provide several examples for tensor reduction of loop integrals with zero Gram determinants. More examples and explanations can be found on the reference pages for [TID](../TID.md), [FCMultiLoopTID](../FCMultiLoopTID.md) and [FCLoopTensorReduce](../FCLoopTensorReduce.md).
Notice that the so-obtained results can be possibly simplified further using IBPs.

**1-loop 1-point rank 2 integral with $p^2=0$**

```mathematica
FCClearScalarProducts[]
SPD[p] = 0;
int = FVD[k, mu] FVD[k, nu] FAD[{k, m}, {k - p}]
(*TID[int,k];*)
(*FCLoopFindTensorBasis[{-p},{},n]*)
TID[int, k, TensorReductionBasisChange -> {{-p} -> {-p, n}}, AuxiliaryMomenta -> {n}]
```

**1-loop 2-point rank 2 integral with $p_1^2=p_2^2 = p_1 \cdot p_2 = s$**

```mathematica
FCClearScalarProducts[];
SPD[p1] = s;
SPD[p2] = s;
SPD[p1, p2] = s;
int = FVD[k, mu] FVD[k, nu] FAD[{k, 0}, {k + p1, m1}, {k + p2, m2}]
(*TID[int,k];*)
(*FCLoopFindTensorBasis[{-p1, -p2}, {}, n]*)
TID[int, k,TensorReductionBasisChange -> {{-p1, -p2} -> {-p1}}, FinalSubstitutions -> {SPD[k, p2] -> SPD[k, p1]}]
```

**1-loop 2-point rank 1 integral with $p_1^2=p_2^2 = p_1 \cdot p_2 = 0$**

```mathematica
FCClearScalarProducts[];
SPD[p1] = 0;
SPD[p2] = 0;
SPD[p1, p2] = 0;
SPD[n] = 0;
int = FVD[k, mu] FVD[k, nu] FAD[{k, 0}, {k + p1, m1}, {k + p2, m2}]
TID[int, k, 
 TensorReductionBasisChange -> {{-p1, -p2} -> {n, -p1}, {-p2} -> {n, -p2}, {-p1} -> {n, -p1}, 
{p2 - p1} -> {n, p2 - p1}}, AuxiliaryMomenta -> {n}]
```







