(* ****************************************************************** *)
(*                                                                    *)
(*                            Automatic.gen                           *)
(*                                                                    *)
(* ****************************************************************** *)

(* 
   Author:              Frederik Orellana 1997

   Summary:             Generic model for FeynArts

   Mathematica Version: 3.0 

   Requirements:        FeynArts > 2, PHI, FeynCalc > 3

   Description:         The coupling vector are loaded from files
                        generated by PHI
*)

(* ****************************************************************** *)

$GenericModel = "Automatic";

(* ****************************************************************** *)

(* The minuses for outgoing particles are removed *)

$VerticesSpecifications1:=($VerticesSpecifications/.-qu_[q__]->qu[q]);

(* ****************************************************************** *)

(* Standard definitions for all PHI particle types *)

PropagatorType[$ScalarHeads]=Straight;
PropagatorType[$VectorHeads]=Sine;
(*PropagatorType[$FermionHeads]=Dashing[{0.003,0.006}];*)
(*FA seems to have lost some flexibility in costumizing the graphics*)
PropagatorType[$FermionHeads]=ScalarDash;

PropagatorArrow[$ParticleHeads]=None;

KinematicIndices[$ScalarHeads] := {};
KinematicIndices[$FermionHeads] := {};
KinematicIndices[$VectorHeads] := {Lorentz};

Appearance[Index[Lorentz,i_]] := 
$CouplingLorentzIndicesString<>ToString[i];

(* ****************************************************************** *)

(*
  The function GenProps[p]
  gives the propagator description for the particle type p.
  Standard definitions are used.
  Notice that the setting of $PropagatorMassesStates determines the 
  renormalization state of the mass used for the propagator of each 
  particle
*)

(* The condition added to allow redifining propagators
   before loading FeynArts *)
If[And@@((Head[GenProps[#]]===GenProps)&/@
({$ScalarHeads /. Alternatives -> Sequence})),
GenProps[a:$ScalarHeads]:={
AnalyticalPropagator[External][ s a[i,p] ] == 1, 
AnalyticalPropagator[Internal][ s a[i,p] ] == 
I*PropagatorDenominator[p,Mass[a[i]]]}];

If[And@@((Head[GenProps[#]]===GenProps)&/@
({$VectorHeads /. Alternatives -> Sequence})),
GenProps[a:$VectorHeads]:={
AnalyticalPropagator[External][ s a[i, mom, {li2}] ] == 
PolarizationVector[ a[i], mom, li2 ], 
AnalyticalPropagator[Internal][ s a[i,mom,{li1}->{li2}] ] == 
I*PropagatorDenominator[ mom , Mass[a[i]] ]*
(-MetricTensor[li1, li2])}];

If[And@@((Head[GenProps[#]]===GenProps)&/@
({$FermionHeads /. Alternatives -> Sequence})),
GenProps[a:$FermionHeads]:={
AnalyticalPropagator[External][ s a[i, mom] ] == 
NonCommutative[ 
DiracSpinor[ -mom, Mass[ a[i] ], Sequence @@ Drop[{i},1] ] ], 
AnalyticalPropagator[Internal][ s a[i,mom] ] == 
NonCommutative[ DiracGamma[ -mom ] + Mass[a[i]] ]*
I*PropagatorDenominator[ mom , Mass[a[i]] ]}];

(* ****************************************************************** *)

(* allfields is all field-types in $VerticesSpecifications
   (that is, Pion[0], Pion[1], ... are not distinguished) *)
(* Change 20/3-1999 - mixing fields must also be included in this list *)

allfields=
Union[Head/@Union[
Flatten[Transpose[Transpose[
$VerticesSpecifications1][[1]]/.Rule->List][[2]]],
If[Length[$MixingFields]>0,Transpose[$MixingFields/.Rule->List][[1]],{}]]];

(* The function GenProps is used to create propagator definitions
   for all particle types *)

M$GenericPropagators = Flatten[GenProps/@allfields];

(* ****************************************************************** *)

(* Only vector-type particles have Lorentz index *)

kineindex[a:$VectorHeads,i_]:={ToExpression[
$CouplingLorentzIndicesString<>ToString[i]]};
kineindex[a:$ScalarHeads,i_]:=Sequence[];
kineindex[a:$FermionHeads,i_]:=Sequence[];

(*
   The coupling vectors are read from the files specified in
   $VerticesSpecifications.  The left-hand side 
   (genericfieldsmomenta) of the defintion and the field
   configuration (genericfields) are created with the fields
   from $VerticesSpecifications.  The symmetry sign is also
   taken from $VerticesSpecifications
*)

(* listrepl substitutes the list PerturbationOrder with
   one element at a time - to pass it to XName *)

(*Added 7/6-2000 to allow a list of non-Automatic XFileName's*)
listrepl[{aa___,PerturbationOrder->b_List,
bb___,XFileName->xn_List,cc___},nn_Integer] :=
{aa,PerturbationOrder->b[[nn]],bb,XFileName->xn[[nn]],cc};

listrepl[{aa___,XFileName->xn_List,
bb___,PerturbationOrder->b_List,cc___},nn_Integer] :=
{aa,PerturbationOrder->b[[nn]],bb,XFileName->xn[[nn]],cc};

(**)

listrepl[{aa___,PerturbationOrder->b_List,bb___},nn_Integer] :=
{aa,PerturbationOrder->b[[nn]],bb};

(
olddir=Directory[];
SetDirectory[$HEPDir];
SetDirectory["HighEnergyPhysics"];
SetDirectory["Phi"];
SetDirectory["CouplingVectors"];

Do[

Do[

(* The coupling vectors are loaded into an array *)

gloadfile[filenr] = XName[listrepl[
$VerticesSpecifications1[[repp]],filenr]]<>".Gen";

VerbosePrint[1,repp," ",filenr,
" Loading generic coupling from ",gloadfile[filenr]];

genericcouplingvector[repp,filenr] = Get[gloadfile[filenr]],

{filenr,Length[PerturbationOrder/.
$VerticesSpecifications1[[repp]]]}];

(* The array is simply joined (flattened) *)

genericcouplingvector[repp] =
Join@@(Table[genericcouplingvector[repp,filenr],
{filenr,Length[PerturbationOrder/.
$VerticesSpecifications1[[repp]]]}]);

genericfields[repp] = 
  Table[ ToExpression["s"<>ToString[rep]]*
  $VerticesSpecifications1[[repp,1,2,rep,0]][
   ToExpression["nr"<>ToString[rep]] ], 
  {rep,1,Length[$VerticesSpecifications1[[repp,1,2]]]} ];

genericfieldsmomenta[repp] =
  Table[ ToExpression["s"<>ToString[rep]]*
  $VerticesSpecifications1[[repp,1,2,rep,0]][
  ToExpression["nr"<>ToString[rep]],
  ToExpression[$CouplingMomentumVariablesString<>ToString[rep]],
  kineindex[$VerticesSpecifications1[[repp,1,2,rep,0]],rep] ], 
  {rep,1,Length[$VerticesSpecifications1[[repp,1,2]]]} ];,
  
{repp,Length[$VerticesSpecifications1]}];

SetDirectory[olddir];);

csign[rr_]:=CouplingSign/.$VerticesSpecifications1[[rr]];

(* ****************************************************************** *)
    
(* The loaded coupling vectors and the constructed left-hand sides are 
   used for constructing the coupling definitions *)

M$GenericCouplings  =
  Union[Table[
  AnalyticalCoupling@@(genericfieldsmomenta[repp])==
  (G[csign[repp]]@@genericfields[repp]).genericcouplingvector[repp],
  {repp,Length[$VerticesSpecifications1]}]];

FixCouplingSigns;

(* ****************************************************************** *)

(* FermionFlipRules: for a certain mapping of Fermion fields in a coupling
   we have to know which operations to perform.
   OVERALL minus signs of the flipping are generated by defining G to be
   anti-symmetric (G[-1]).
   In this model, flip rules are applied for FSS- and FFV-couplings.
   FSS contains only omega[+/-], so none of the rules matches. FVV
   is antisymmetric and the rules match, resulting in
   ga_mu omega[+] ->  - ga_mu omega[-]
   ga_mu omega[-] ->  - ga-mu omega[+]. *)

M$FermionFlipRule[ 1->2, 2->1, ___ ] =
{
  NonCommutative[ DiracGamma[li_],ChiralityProjector[ 1]] :>
  - NonCommutative[ DiracGamma[li], ChiralityProjector[-1] ],
  NonCommutative[ DiracGamma[li_],ChiralityProjector[-1]] :>
  - NonCommutative[ DiracGamma[li], ChiralityProjector[ 1] ]
};

(* ****************************************************************** *)

M$LastGenericRules = {
(* Outgoing vector bosons: throw away signs of momenta *)
PolarizationVector[
p_, _. k:(FourMomentum[ Outgoing, i_Integer ]), li_ ] :> 
Conjugate[PolarizationVector][ p, k, li ] ,

(* for the case of self-energies *)
PolarizationVector[
p_, k:(- FourMomentum[ Incoming, 1 ]), li_ ] :> 
Conjugate[PolarizationVector][ p, k, li ],

(* relicts of the truncation of spinors: *)
   
Dot[ 1, line__, 1 ] :> Dot[ line ],
Dot[ 1, 1 ] :> 1 };

(**)
